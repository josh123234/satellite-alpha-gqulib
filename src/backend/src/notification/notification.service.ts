import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
  INotification,
  NotificationType,
  NotificationPriority,
  NotificationStatus,
  NotificationMetadata
} from './interfaces/notification.interface';
import {
  CreateNotificationDto,
  UpdateNotificationDto,
  NotificationResponseDto,
  BatchNotificationDto
} from './dto/notification.dto';
import { NotificationRepository } from './repositories/notification.repository';
import { WebsocketGateway } from '../websocket/websocket.gateway';
import { SocketEventType } from '../websocket/interfaces/socket-event.interface';
import { PaginatedDto, PaginationOptions } from '../common/decorators/api-paginated-response.decorator';

@Injectable()
export class NotificationService {
  // Constants for configuration
  private readonly MAX_BATCH_SIZE = 100;
  private readonly NOTIFICATION_TTL = 30 * 24 * 60 * 60 * 1000; // 30 days in milliseconds
  private readonly PRIORITY_THRESHOLDS = new Map<NotificationPriority, number>([
    [NotificationPriority.URGENT, 0], // Immediate
    [NotificationPriority.HIGH, 1000], // 1 second
    [NotificationPriority.MEDIUM, 5000], // 5 seconds
    [NotificationPriority.LOW, 15000], // 15 seconds
  ]);

  constructor(
    @InjectRepository(NotificationRepository)
    private readonly notificationRepository: NotificationRepository,
    private readonly webSocketGateway: WebsocketGateway
  ) {}

  /**
   * Creates a new notification with priority-based delivery
   */
  async createNotification(
    createNotificationDto: CreateNotificationDto
  ): Promise<NotificationResponseDto> {
    // Validate and normalize input
    this.validateNotificationInput(createNotificationDto);

    // Create notification entity
    const notification: INotification = {
      ...createNotificationDto,
      id: undefined, // Will be generated by DB
      status: NotificationStatus.UNREAD,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // Save to database
    const savedNotification = await this.notificationRepository.save(notification);

    // Schedule real-time delivery based on priority
    const deliveryDelay = this.PRIORITY_THRESHOLDS.get(notification.priority);
    setTimeout(() => {
      this.broadcastNotification(savedNotification);
    }, deliveryDelay);

    return this.mapToResponseDto(savedNotification);
  }

  /**
   * Creates multiple notifications in batch with optimized processing
   */
  async createBatchNotifications(
    batchNotificationDto: BatchNotificationDto[]
  ): Promise<NotificationResponseDto[]> {
    if (!Array.isArray(batchNotificationDto) || batchNotificationDto.length > this.MAX_BATCH_SIZE) {
      throw new Error(`Batch size cannot exceed ${this.MAX_BATCH_SIZE} notifications`);
    }

    // Process notifications in chunks for optimal performance
    const notifications: INotification[] = batchNotificationDto.map(dto => ({
      ...dto,
      id: undefined,
      status: NotificationStatus.UNREAD,
      createdAt: new Date(),
      updatedAt: new Date()
    }));

    // Batch save to database
    const savedNotifications = await this.notificationRepository.batchCreate(notifications);

    // Schedule broadcasts based on priority
    savedNotifications.forEach(notification => {
      const deliveryDelay = this.PRIORITY_THRESHOLDS.get(notification.priority);
      setTimeout(() => {
        this.broadcastNotification(notification);
      }, deliveryDelay);
    });

    return savedNotifications.map(notification => this.mapToResponseDto(notification));
  }

  /**
   * Retrieves paginated notifications for an organization
   */
  async getNotificationsByOrganization(
    organizationId: string,
    options: PaginationOptions,
    filters?: { type?: NotificationType; status?: NotificationStatus }
  ): Promise<PaginatedDto<NotificationResponseDto>> {
    const notifications = await this.notificationRepository.findByOrganizationId(
      organizationId,
      options
    );

    return {
      ...notifications,
      data: notifications.data.map(notification => this.mapToResponseDto(notification))
    };
  }

  /**
   * Retrieves unread notifications for a user with priority sorting
   */
  async getUnreadNotifications(
    userId: string
  ): Promise<NotificationResponseDto[]> {
    const notifications = await this.notificationRepository.findUnreadByUserId(userId);
    return notifications.map(notification => this.mapToResponseDto(notification));
  }

  /**
   * Marks multiple notifications as read with optimistic locking
   */
  async markNotificationsAsRead(
    userId: string,
    notificationIds: string[]
  ): Promise<void> {
    await this.notificationRepository.markAsRead(userId, notificationIds);

    // Broadcast status update
    const roomId = `user_${userId}`;
    this.webSocketGateway.broadcastToUser(roomId, {
      type: SocketEventType.SUBSCRIPTION_UPDATED,
      payload: {
        notificationIds,
        status: NotificationStatus.READ
      }
    });
  }

  /**
   * Broadcasts a notification through WebSocket based on type
   */
  private broadcastNotification(notification: INotification): void {
    // Broadcast to organization room
    const orgRoom = `org_${notification.organizationId}`;
    const userRoom = `user_${notification.userId}`;

    switch (notification.type) {
      case NotificationType.SUBSCRIPTION_RENEWAL:
        this.webSocketGateway.broadcastToRoom(orgRoom, {
          type: SocketEventType.SUBSCRIPTION_UPDATED,
          payload: this.mapToResponseDto(notification)
        });
        break;

      case NotificationType.USAGE_THRESHOLD:
        this.webSocketGateway.broadcastToUser(userRoom, {
          type: SocketEventType.USAGE_ALERT,
          payload: this.mapToResponseDto(notification)
        });
        break;

      case NotificationType.AI_INSIGHT:
        this.webSocketGateway.broadcastToUser(userRoom, {
          type: SocketEventType.AI_INSIGHT,
          payload: this.mapToResponseDto(notification)
        });
        break;

      default:
        this.webSocketGateway.broadcastToUser(userRoom, {
          type: SocketEventType.SUBSCRIPTION_UPDATED,
          payload: this.mapToResponseDto(notification)
        });
    }
  }

  /**
   * Validates notification input data
   */
  private validateNotificationInput(dto: CreateNotificationDto): void {
    if (!dto.organizationId || !dto.userId || !dto.type || !dto.title || !dto.message) {
      throw new Error('Missing required notification fields');
    }

    if (!Object.values(NotificationType).includes(dto.type)) {
      throw new Error('Invalid notification type');
    }

    if (dto.priority && !Object.values(NotificationPriority).includes(dto.priority)) {
      throw new Error('Invalid notification priority');
    }
  }

  /**
   * Maps notification entity to response DTO
   */
  private mapToResponseDto(notification: INotification): NotificationResponseDto {
    return {
      id: notification.id,
      organizationId: notification.organizationId,
      userId: notification.userId,
      type: notification.type,
      priority: notification.priority,
      status: notification.status,
      title: notification.title,
      message: notification.message,
      metadata: notification.metadata,
      createdAt: notification.createdAt,
      updatedAt: notification.updatedAt
    };
  }
}